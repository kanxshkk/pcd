nfa = [
    4,# 0
    ['A', 'B', 'C', 'D'],  # array of states 1
    3,  # number of alphabets 2 
    ['a', 'b', 'c'],  # ip 3 
    'A',  # start state 4 
    1,  # number of final states 5 
    ['D'],  # final states 6
    7, #7
    [['A', 'a', 'A'], ['A', 'e', 'B'], ['B', 'b', 'B'],
     ['A', 'e', 'C'], ['C', 'c', 'C'], ['B', 'b', 'D'],
     ['C', 'c', 'D']]# 8
]

def Eclosure(q1):
    ecol=set()
    ecol.add(q1)
    for i in range(len(nfa[8])):
        if nfa[8][i][0]==q1 and nfa[8][i][1]=="e":
            ecol.add(nfa[8][i][2])
    return ecol

dfa_start = Eclosure(nfa[4])
'''
dfa_final = []
for x in nfa[1]:#states
    if x in nfa[6]:#final state
        dfa_final.append(x)
'''
#makeeclosure dict for ez access
epsilon_closure = dict()
for x in nfa[1]:#states
    epsilon_closure[x] = Eclosure(x)

#dfa  
    
def trans(q1,ip):
    q2=set()
    for i in range(len(nfa[8])):
        if nfa[8][i][0]==q1 and nfa[8][i][1]==ip:
            q2.add(nfa[8][i][2])
    return q2
          
def dfa_trans(q1,ip):
    q2=set()
    for i in q1:
         q2= q2.union(trans(i,ip))
    return q2
    
dfa_meta=[]
dfa = {}
q = []
#here is a dfa for start state 
for ip in nfa[3]:
    a=set()
    for i in dfa_trans(dfa_start,ip):
        a=a.union(epsilon_closure[i])
    q.append(a)
    dfa[tuple(dfa_start)] =  a
    print(ip)
    print(dfa)
    dfa_meta.append(dict(dfa))

# need to procee with same technique for all states with stack
while (q!=[]):
    if tuple(q[0]) in dfa_meta:
        q.pop(0)
    else:
        for ip in nfa[3]:
            a=set()
            for i in dfa_trans(q[0],ip):
                a=a.union(epsilon_closure[i])
            q.append(a)
            dfa[tuple(dfa_start)] =  a
            print(ip)
            print(dfa)
            dfa_meta.append(dict(dfa))
